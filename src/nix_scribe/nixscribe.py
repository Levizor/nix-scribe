import datetime
import logging
import os

from rich.console import Console

from nix_scribe.lib.modularization import ModularizationLevel

from .arguments import args, confirm
from .lib.context import ElevationRequest, SystemContext
from .lib.nixfile import NixFile
from .modules.base import Module
from .modules.programs import bash
from .modules.security import sudo
from .modules.services.desktopManager import gnome, plasma6
from .modules.services.displayManager import gdm, sddm
from .modules.users import groups, users
from .modules.virtualisation import virtualisation

logger = logging.getLogger(__name__)

OPTIONS: dict[str, list[Module]] = {
    "boot": [],
    "environment": [],
    "hardware": [],
    "networking": [],
    "programs": [bash.module],
    "security": [sudo.module],
    "services": [plasma6.module, gnome.module, gdm.module, sddm.module],
    "users": [groups.module, users.module],
    "virtualisation": [virtualisation.module],
    "xdg": [],
}


class NixScribe:
    def __init__(self, console: Console):
        self.context = SystemContext(args.input_path, use_sudo=os.geteuid() == 0)
        self.root_file = NixFile("configuration", "Generated by nix-scribe")
        self.modules: list[Module] = [sudo.module]
        self.console = console

    def run(self):
        """
        Top level script.
        Scans, maps, and writes configuration.
        """
        logger.debug(datetime.datetime.now())
        logger.info("Starting nix-scribe system scan...")
        for option_name, modules in OPTIONS.items():
            logger.debug(f"Scanning {option_name}")
            for module in modules:
                self._scan_module(module)

        logger.info(f"Finished system scan. {len(self.modules)} modules scanned.")

        logger.info("Mapping scanned data to nix option blocks...")
        for option_name, modules in OPTIONS.items():
            logger.debug(f"Mapping {option_name}")
            option_file = NixFile(option_name, f"{option_name} configuration")
            for module in modules:
                module.run_map()
                if module.option_block:
                    if args.modularization == ModularizationLevel.COMPONENT_LEVEL:
                        component_file = NixFile(
                            module.name, options=[module.option_block]
                        )
                        option_file.add_import(component_file)
                    elif args.modularization == ModularizationLevel.HIGH_LEVEL:
                        option_file.add_option_block(module.option_block)
                    elif args.modularization == ModularizationLevel.SINGLE_FILE:
                        self.root_file.add_option_block(module.option_block)

            if args.modularization != ModularizationLevel.SINGLE_FILE and (
                any(option_file.imports) or any(option_file.options)
            ):
                self.root_file.add_import(option_file)

        logger.info("Finished mapping stage.")

        logger.info("Writing configuration...")
        self.root_file.save(args.output_path, args.modularization)

        logger.info(f"Saved configuration to {args.output_path}")

    def _scan_module(self, mod: Module):
        """
        Runs a scanner, handling permission requests
        """
        while True:
            with self.console.status(
                status=f"[bold blue]Scanning {mod.name}[/]"
            ) as status:
                try:
                    mod.run_scan(self.context)
                    status.stop()
                    logger.info(f"Scanned [cyan]{mod.name}[/]")
                    break
                except ElevationRequest as e:
                    status.stop()
                    logger.warning(f"Permission denied: {e.description}")

                    if self.context.use_sudo:
                        logger.error(
                            "Sudo was attempted, but failed (authentication or access failure). Skipping."
                        )
                        return {}

                    if self._prompt_for_sudo():
                        if self.context.verify_sudo():
                            logger.info("[bold green]Sudo privileges acquired![/]")
                            continue
                        else:
                            logger.warning("Sudo authentication failed. Skipping.")
                            return {}
                    else:
                        logger.warning("Skipping this scanner.")
                        return {}
                except Exception as e:
                    status.stop()
                    logger.error(f"Failed scanning {mod.name}: {e}")
                    return {}

    def _prompt_for_sudo(self) -> bool:
        try:
            return confirm(
                "[bold yellow]Permission required.[/] Do you want to retry with sudo privileges?",
                console=self.console,
                default=True,
            )
        except EOFError:
            return False
