import datetime
import logging
import os

from rich.console import Console

from nix_scribe.lib.modularization import ModularizationLevel

from .arguments import args, confirm
from .lib.context import ElevationRequest, SystemContext
from .lib.loader import ModuleLoader
from .lib.nixfile import NixFile
from .modules.base import Module

logger = logging.getLogger(__name__)


class NixScribe:
    def __init__(self, console: Console):
        self.context = SystemContext(args.root_path, use_sudo=os.geteuid() == 0)
        self.root_file = NixFile("configuration", "Generated by nix-scribe")

        self.loader = ModuleLoader()
        self.categories = self.loader.discover()

        self.console = console

    def run(self):
        """
        Top level script.
        Scans system, maps ir, and writes configuration.
        """
        logger.debug(datetime.datetime.now())
        logger.info("Starting nix-scribe system scan...")

        category_names = sorted(self.categories.keys())

        for category in category_names:
            modules = self.categories[category]
            if not modules:
                continue
            logger.debug(f"Scanning {category}")
            for module in modules:
                self._scan_module(module)

        total_modules = sum(len(mods) for mods in self.categories.values())
        logger.info(f"Finished system scan. {total_modules} modules scanned.")

        logger.info("Mapping scanned data to nix option blocks...")
        for category in category_names:
            modules = self.categories[category]
            if not modules:
                continue
            logger.debug(f"Mapping {category}")
            option_file = NixFile(category, f"{category} configuration")
            for module in modules:
                module.run_map()
                if module.option_block:
                    if args.modularization == ModularizationLevel.COMPONENT_LEVEL:
                        component_file = NixFile(
                            module.name, options=[module.option_block]
                        )
                        option_file.add_import(component_file)
                    elif args.modularization == ModularizationLevel.HIGH_LEVEL:
                        option_file.add_option_block(module.option_block)
                    elif args.modularization == ModularizationLevel.SINGLE_FILE:
                        self.root_file.add_option_block(module.option_block)

            if args.modularization != ModularizationLevel.SINGLE_FILE and (
                any(option_file.imports) or any(option_file.options)
            ):
                self.root_file.add_import(option_file)

        logger.info("Finished mapping stage.")

        logger.info("Writing configuration...")
        self.root_file.save(args.output_path, args.modularization, self.context)

        logger.info(f"Done. Saved configuration to {args.output_path}")

    def _scan_module(self, mod: Module):
        """
        Runs a scanner, handling permission requests
        """
        while True:
            with self.console.status(
                status=f"[bold blue]Scanning {mod.name}[/]"
            ) as status:
                try:
                    mod.run_scan(self.context)
                    status.stop()
                    logger.info(f"Scanned [cyan]{mod.name}[/]")
                    break
                except ElevationRequest as e:
                    status.stop()
                    logger.warning(f"Permission denied: {e.description}")

                    if self.context.use_sudo:
                        logger.error(
                            "Sudo was attempted, but failed (authentication or access failure). Skipping."
                        )
                        return {}

                    if self._prompt_for_sudo():
                        if self.context.verify_sudo():
                            logger.info("[bold green]Sudo privileges acquired![/]")
                            continue
                        else:
                            logger.warning("Sudo authentication failed. Skipping.")
                            return {}
                    else:
                        logger.warning("Skipping this scanner.")
                        return {}
                except Exception as e:
                    status.stop()
                    logger.error(f"Failed scanning {mod.name}: {e}")
                    return {}

    def _prompt_for_sudo(self) -> bool:
        try:
            return confirm(
                "[bold yellow]Permission required.[/] Do you want to retry with sudo privileges?",
                console=self.console,
                default=True,
            )
        except EOFError:
            return False
